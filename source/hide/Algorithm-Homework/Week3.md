title: Algorithm-Homework-3
date: 2016-09-22 11:04:10
categories:
- 算法设计与分析
- 作业
tags:
- 分治算法
---

# 算法设计与分析作业 #3

Copyright © zccz14(陈铮), All Right Reserved.

## 算法分析题

2-3 设 a[0: n - 1] 是已排好序的数组。请改写二分搜索算法，使得当搜索元素 x 不在数组中时，返回小于 x 的最大元素位置 i 和大于 x 的最小元素位置 j。当搜索元素在数组中时， i 和 j 相同，均为 x 在数组中的位置。

1. 初始化 i = -1, j = n (假设 a 升序并且, $ a_{-1} = -\infty, a_{n} = +\infty $)

2. 显而易见，停机时 $j - i \le 1$，即 $ [i, j] $ 的区间长度一定小于等于1。否则一定可以进一步缩小区间。如果 $ i = j $，则 $ x = a_i = a_j $；如果 $ i + 1 = j $，则 $ x \not \in a, a_i \lt x \lt a_j $。

{% include_code "C++ 实现" lang:cpp Algorithm-Homework-Reference/A-2-3.cpp %}

2-4 给定两个大整数 u 和 v，它们分别有 m 和 n 位数字，且 $ m \le n $。用通常的乘法求 $ u v $ 的值需要 $ O(m n) $ 时间。可以将 u 和 v 均看作是有 n 位数字的大整数，用本章介绍的分治法，在 $ O(n ^ {\log 3} ) $ 时间内计算 $ u v $ 的值。当 m 比 n 小得多时，用这种方法就显得效率不够高。试设计一个算法，在上述情况下用 $ O(n m ^ {\log \frac{3}{2}}) $ 时间求出 $ u v $ 的值。



2-6 对任何非零偶数 n ，总可以找到奇数 m 和正整数 k ，使得 $ n = m 2^k $ 。为了求出两个 n 阶矩阵的乘积，可以把一个 n 阶矩阵分成 $ m \times m $ 个子矩阵，每个子矩阵有 $ 2^k \times 2^k $ 个元素。当需要求 $ 2^k \times 2^k $ 的子矩阵的积时，使用 Strassen 算法。设计一个传统方法与 Strassen 算法相结合的矩阵相乘算法，对任何偶数 n，都可以求出两个 n 阶矩阵的乘积。并分析算法的计算时间复杂性。

2-7 设 $ P(x) = a_0 + a_1 x + \cdots + a_d x^d $ 是一个 $ d $ 次多项式。假设已有一个算法能在 $ O(i) $ 时间内计算一个 $ i $ 次多项式与一个一次多项式的乘积，以及一个算法能在 $ O(i \log i) $ 时间内计算两个 $ i $ 次多项式的乘积。对于任意给定的 $ d $ 个整数 $ n_1, n_2, \cdots, n_d $，用分治法设计一个有效算法，计算出满足 $ P(n_1) = P(n_2) = \cdots = P(n_d) = 0 $ 且最高次项系数为 1 的 $ d $ 次多项式 $ P(x) $，并分析算法的效率。

2-10 如果在合并排序算法的分割步骤中，将数组 a[0: n - 1] 划分为 $ \lfloor \sqrt{n} \rfloor $ 个子数组，每个子数组中有 $ O(\sqrt{n}) $ 个元素，然后递归地对分割后的子数组进行排序，最后将所得到的 $ \lfloor \sqrt{n} \rfloor $ 个排好序的子数组合并成所要求的排好序的数组 a[0: n - 1]。设计一个实现上述策略的合并排序算法，并分析算法的计算复杂性。

2-13 如何修改 QuickSort 算法才能使其将输入元素按非增序排序？

2-14 Gray码是一个长度为 $ 2^n $ 的序列。序列中无相同元素，每个元素都是长度为 n 位的 (0, 1) 串，相邻元素恰好只有一位不同。用分治策略设计一个算法对任意的 n 构造相应的 Gray 码。


## 算法实现题

### 2-3 半数集问题

给定一个自然数 n，由 n 开始可以依次产生半数集 $ set(n) $ 中的数如下：

1. $ n \in set(n) $；
2. 在 $ n $ 的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；
3. 按此规则进行处理，直到不能再添加自然数为止。

例如， $ set(6) = \{6, 16, 26, 126, 36, 136\} $。半数集 $ set(6) $ 中有 6 个元素。

注意，该半数集是多重集。

对于给定的自然数 $ n $，计算半数集 $ set(n) $ 中的元素个数。

#### 输入描述

第一行是一个整数 $ n, (0 \lt n \lt 1000)$。

#### 输出描述

第一行是半数集 $ set(n) $ 中的元素个数。

#### 输入样例

```
6
```

#### 输出样例

```
6
```

#### 题解

解释一下样例的计算步骤

1. $ 6 \in set(6) $
2. $ 16, 26, 36 \in set(6) $
3. $ 126, 136 \in set(6) $

可以发现答案是递归定义的：

$$
f(n) = 1 + \sum_{ i } { [ 1 \le i \le \lfloor \frac{n}{2} \rfloor ] f(i) } \tag 1
$$

这个递归式隐含了边界条件。

{% include_code "Half Set - Time: O(n ^ 2) - Space: O(n)" Algorithm-Homework-Reference/2-3.cpp lang:cpp %}

进一步地，观察 $ f(n) $ 的差分我们可以推导出另外一个递归式：

$$
f(n) = \begin{cases}
  1 & n = 1 \\
  f(n - 1) + [n \equiv 0 \mod 2] f(\lfloor \frac{n}{2} \rfloor)) & n \ge 2 \\
\end{cases}
$$

一个简单的递归实现：

{% include_code "Half Set - Time: O(n) - Space: O(n) - Recursive" Algorithm-Homework-Reference/2-3-1.cpp lang:cpp %} 

或许使用迭代更加有效率：

{% include_code "Half Set - Time: O(n) - Space: O(n) - Iterative" Algorithm-Homework-Reference/2-3-2.cpp lang:cpp %} 


### 2-5 有重复元素的排列问题

设 $ R = \{ r_1, r_2, \cdots, r_n \} $ 是要进行排列的 $ n $ 个元素。其中元素 $ r_1, r_2, \cdots, r_n $ 可能相同。试设计一个算法，列出 $ R $ 的所有不同排列。

给定 $ n $ 及待排列的 $ n $ 个元素，计算出这 n 个元素的所有不同排列。

#### 输入描述

第 1 行是元素个数 $ n, (1 \le n \le 500) $。

接下来的 1 行是待排列的 $ n $ 个元素（字符）。


#### 输出描述

输出 n 个元素的所有不同排列。

最后 1 行输出排列的总数。

#### 输入样例

```
4
aacc
```

#### 输出样例

```
aacc
acac
acca
caac
caca
ccaa
6
```

#### 题解

细思恐极的复杂度 $ O(n n!) $ 对于 $ n = 500 $ 的情况下，计算量高达 $ 500 \times 500! = 6.1 \times 10^{1136} $

excuse me??? ( 黑人问号 )

> 这是一个 NP Hard 问题。
